import planTaskInputSchema from "../schemas/planTaskInput.json" with { type: "json" };
import taskContractSchema from "../schemas/taskContract.json" with { type: "json" };
import retrieveInputSchema from "../schemas/retrieveInput.json" with { type: "json" };
import evidenceCardListSchema from "../schemas/evidenceCardList.json" with { type: "json" };
import compileCapsuleInputSchema from "../schemas/compileCapsuleInput.json" with { type: "json" };
import executionCapsuleSchema from "../schemas/executionCapsule.json" with { type: "json" };
import runCapsuleInputSchema from "../schemas/runCapsuleInput.json" with { type: "json" };
import runResultSchema from "../schemas/runResult.json" with { type: "json" };
import reflectInputSchema from "../schemas/reflectInput.json" with { type: "json" };
import reflectionReportSchema from "../schemas/reflectionReport.json" with { type: "json" };
import renderInputSchema from "../schemas/renderInput.json" with { type: "json" };
import renderOutputSchema from "../schemas/renderOutput.json" with { type: "json" };
import { planTask } from "./tools/planTask.js";
import { compileCapsule } from "./tools/compileCapsule.js";
import { runCapsule } from "./tools/runCapsule.js";
import { reflectPipeline } from "./tools/reflectPipeline.js";
import { retrieveEvidence } from "./tools/retrieveEvidence.js";
import { renderWithPointers } from "./tools/renderWithPointers.js";
import { generateEvidence } from "./tools/generateEvidence.js";
import { executeFullWorkflow } from "./tools/executeFullWorkflow.js";
import generateEvidenceInputSchema from "../schemas/generateEvidenceInput.json" with { type: "json" };
import { router as evidenceRouter } from "./resources/evidence.js";
import { router as artifactRouter } from "./resources/artifact.js";
import { router as logRouter } from "./resources/log.js";
import { createPromptRegistry } from "./prompts/index.js";

export type ToolDescriptor = {
  name: string;
  description: string;
  inputSchema: Record<string, unknown>;
  outputSchema?: Record<string, unknown>;
  handler: (input: any) => Promise<any>;
};

export type ResourceDescriptor = {
  uri: string;
  description: string;
  reader: (path: string) => Promise<unknown>;
};

export function registerAll() {
  const tools: ToolDescriptor[] = [
    {
      name: "execute_full_workflow",
      description: "Automatically execute complete MCP workflow: planning → compilation → execution → reflection",
      inputSchema: planTaskInputSchema,
      handler: executeFullWorkflow
    },
    {
      name: "generate_evidence",
      description: "Generate new evidence via LLM sampling and save with pointers",
      inputSchema: generateEvidenceInputSchema,
      outputSchema: evidenceCardListSchema,
      handler: generateEvidence
    },
    {
      name: "plan_task",
      description: "Decompose a goal into a TaskContract",
      inputSchema: planTaskInputSchema,
      outputSchema: taskContractSchema,
      handler: planTask
    },
    {
      name: "retrieve_evidence",
      description: "Retrieve pointer-first evidence cards",
      inputSchema: retrieveInputSchema,
      outputSchema: evidenceCardListSchema,
      handler: retrieveEvidence
    },
    {
      name: "compile_capsule",
      description: "Compile a TaskContract into an ExecutionCapsule",
      inputSchema: compileCapsuleInputSchema,
      outputSchema: executionCapsuleSchema,
      handler: compileCapsule
    },
    {
      name: "run_capsule",
      description: "Execute a one-shot capsule inside the sandbox",
      inputSchema: runCapsuleInputSchema,
      outputSchema: runResultSchema,
      handler: runCapsule
    },
    {
      name: "reflect_pipeline",
      description: "Reflect on run outputs and detect conflicts",
      inputSchema: reflectInputSchema,
      outputSchema: reflectionReportSchema,
      handler: reflectPipeline
    },
    {
      name: "render_with_pointers",
      description: "Validate draft output with pointer references",
      inputSchema: renderInputSchema,
      outputSchema: renderOutputSchema,
      handler: renderWithPointers
    }
  ];

  const toolMap = new Map(tools.map((tool) => [tool.name, tool]));

  const resources: ResourceDescriptor[] = [
    { uri: "evidence://", description: "Evidence cards and passages (read only)", reader: evidenceRouter() },
    { uri: "artifact://", description: "Artifacts generated by runs", reader: artifactRouter() },
    { uri: "log://", description: "Structured execution logs", reader: logRouter() }
  ];

  const resourceMap = new Map(resources.map((res) => [res.uri, res]));

  const { promptList, promptMap } = createPromptRegistry();

  return { tools, toolMap, resources, resourceMap, promptList, promptMap };
}
